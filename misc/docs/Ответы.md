https://github.com/theberrigan/test-movie-catalog

# Ответы на вопросы


## Вопрос 1
_**Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?**_

**Когда происходит событие, оно проходит три фазы:**
1. **Фаза захвата (capture)** – сначала событие движется от корня иерархии (```window``` или ```document```) к элементу, непосредственно на котором произошло это событие (target-элемент). На этом пути вызываются все слушатели, которые были повешены на элементы с помощью ```addEventListener(..., ..., true)```. Здесь третий аргумент, равный ```true```, как раз говорит о том, что слушатель должен вызываться на этой фазе. 
2. **Фаза цели (target)** – на этом этапе вызываются все слушатели, повешенные на target-элемент.
3. **Всплытие (bubbling)** – событие движется в обратном направлении (всплывает) – от target к ```window```/```document```. Вызываются все слушатели, повешенные с помощью ```addEventListener(..., ..., false)```. 


**Несколько моментов:**
- Перечисленные ниже варианты навешивания слушателей эквивалентны.  
  Все они сработают на этапе всплытия:
  - ```el.addEventListener('click', () => {})```
  - ```el.addEventListener('click', () => {}, false)```
  - ```el.onclick = () => {}```
- Несколько слушателей, повешенные на одно и то же событие одного и того же элемента, вызываются в том порядке, в котором они вешались, но сначала все capture-слушатели, а затем все bubble-слушатели.  
  ```js
  el.addEventListener('click', () => console.log(1), true);
  el.addEventListener('click', () => console.log(2), false);
  el.addEventListener('click', () => console.log(3), true);
  el.addEventListener('click', () => console.log(4), false);
  el.onclick = () => console.log(5);
  ```

  Выведется:  
  ```
  1
  2
  3
  4
  5
  ```
- Остановить дальнейшее продвижение события (propagation), независимо от фазы можно с помощью ```e.stopPropagation()```.
- Если для какого-то события в браузере задано действие по умолчанию (например, переход по ссылке при клике на неё), можно вызвать ```e.preventDefault()```, чтобы отменить это действие.


## Вопрос 2
_**Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?**_

Для каждой вкладки браузер запускает цикл, который работает на протяжении всей жизни этой вкладки. Он называется Event Loop (EL). На каждой итерации этого цикла браузер делает много разных задач. Одна из них – выполнение JS-кода.

За одну итерацию EL в JS-движке происходит следующее:
1. Выполняется весь синхронный код в колл-стеке, до тех пор, пока он не опустеет. Этот синхронный код может создавать асинхронные задачи, которые попадают в две разные очереди:
   - **Очередь _микротасков_**. Этими задачами являются функции ```fn```, переданные в ```promise.then/catch/finally(fn)```, ```new MutationObserver(fn)``` или ```queueMicrotask(fn)```.
   - **Очередь _макротасков_**. В эту очередь попадают функции  ```fn```, переданные в ```setTimeout(fn)```, ```setInterval(fn)```, ```fetch```/XHR-запросы, обработчики событий.
2. Браузер выполняет все задачи из очереди микротасков, отправляя их в колл-стек.
3. Выбирается одна задача из очереди макротасков и так же выполняется в колл-стеке.  

По мере выполнения тасков могут создаваться новые микро-/макротаски, поэтому на следующей итерации EL JS-движок снова должен будет их выполнять.

Вместо писанины лучше показать псевдокод:

```C
void main () {
    // Event Loop
    while (!shouldCloseTab()) {
        // делать всякие браузерные дела...
        executeJS();
        // делать всякие браузерные дела...
    }
}

void executeJS () {
    executeSyncJSCode();
    executeAllMicrotasks();
    executeOneMacrotask();
}
```

**Promise** 

Новый инстанс промиса принимает функцию ```fn```, результат выполнения которой он _обещает_ отдать позднее. Этой функции он передаёт два коллбека ```resolve``` и ```reject```. До тех пор, пока ```fn``` не вызовет ```resolve``` с результатом вычисления, ```reject``` с ошибкой вычисления, или пока в ```fn``` не выпадет исключение, промис находится в состоянии ```pending```. Вызов ```resolve``` переводит его в состояние ```fulfilled```, а вызов ```reject``` или исключение переводит промис в состояние ```rejected```. Принять результат вычисления ```fn``` можно с помощью метода ```.then()```, обработать ошибку/исключение – в методе ```.catch()```, а выполнить какое-то действие независимо от состояния ```fulfilled```/```rejected``` можно с помощью метода ```.finally()```. С промисами неразрывно связаны операторы ```async```/```await```, которые делают код более линейным, красивым и компактным.


## Вопрос 3
_**Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript.**_

ООП – это способ объединить данные и связанные с ними функции в одну сущность – класс/объект.

Основные принципы ООП тесно друг с другом связаны:  
- **Инкапсуляция** – класс не даёт прямого доступа к некоторым своим методам и свойствам напрямую. Во многих языках для управления видимостью методов и свойств есть ключевые слова ```public```/```protected```/```private```. Например, в Typescript. В JS их не хватает. 

  Пример в старом JS:
  ```js
  function User () {
      var _id = null;  // private
  
      this.setId = function (id) {
          _id = id;
      };
  
      this.getId = function () {
          return _id;
      };
  }
  
  var user = new User();
  
  user.setId(451);
  
  console.log(user.getId());
  ```

  Пример в JS ES2022:
  ```js
  class User {
      #id = null;  // private
  
      setId (id) {
          this.#id = id;
      }
  
      getId () {
          return this.#id;
      }
  }
  
  const user = new User();
  
  user.setId(451);
  
  console.log(user.getId());
  ```
- **Наследование** – позволяет создавать производные классы, которые наследуют методы и свойства от родительского.

  Пример в JS ES5:
  ```js
  function BaseUser (name) {
      this.name = name;
  }

  BaseUser.prototype.getName = function() {
      return this.name;
  };

  function DashboardUser (name, role) {
      BaseUser.call(this, name);  // эквивалент super(name)
      this.role = role;
  }

  // В качестве прототипа используем инстанс BaseUser
  DashboardUser.prototype = Object.create(BaseUser.prototype);

  DashboardUser.prototype.getRole = function() {
      return this.role;
  };

  const user = new DashboardUser('Unnamed', 'moderator');
  
  console.log(user.getName());
  console.log(user.getRole());  
  ```

  Пример в JS ES6:
  ```js
  class BaseUser {
      constructor (name) {
          this.name = name;
      }
  
      getName () {
          return this.name;
      }
  }

  class DashboardUser extends BaseUser {
      constructor (name, role) {
          super(name);
  
          this.role = role;
      }
    
      getRole () {
          return this.role;
      }
  }

  const user = new DashboardUser('Unnamed', 'moderator');
  
  console.log(user.getName());
  console.log(user.getRole());
  ```
- **Полиморфизм** - позволяет использовать в одном месте инстансы разных классов, которые реализуют один и тот же интерфейс.
  Пример в JS ES2022:
  ```js  
  class Car {  
      #velocity = 0;

      accelerate (delta) {
          this.#velocity += delta;
      }
  }

  class Boat {
      #velocity = 0;

      accelerate (delta) {
          this.#velocity += delta;
      }
  }

  const accelerate = (vehicle, delta) => {
      vehicle.accelerate(delta);
  };

  const car  = new Car();
  const boat = new Boat();

  accelerate(car, 5);
  accelerate(boat, 10);
  ```

## Вопрос 4
_**Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное взаимодействие) могут возникать в процессе?**_

1. Устройства в сети находят друг друга по IP-адресам, а не по доменам. Поэтому, если в URL на месте хоста домен, а не IP-адрес, то браузер сначала отправляет запрос к DNS-серверу, чтобы узнать IP-адрес, который этому домену соответствует. Для ускорения здесь можно использовать кэширование ответа от DNS-сервера.
2. Когда IP определён, браузер устанавливает соединение с сервером, которому этот IP соответствует. Если протокол соединения HTTPS, то браузер устанавливает безопасное соединение, то есть данные, которые будут течь по этому соединению, будут шифроваться.
3. Браузер отправляет HTTP-запрос на сервер с указанием версии протокола, path и заголовками. Здесь для ускорения можно кэшировать ответы с помощью заголовков Cache-Control, ETag, а также Connection/Keep-Alive для удержания соединения, чтобы использовать его в будущем для подгрузки других ресурсов.
4. Браузер получает ресурс и, если нужно, кэширует его.
5. Закрывает соединение, если не Connection/Keep-Alive.

Безопасность:
- Если протокол запроса HTTP, а не HTTPS, то такой запрос может быть перехвачен злоумышленниками, и чувствительные данные могут оказаться у них в руках (пароли, логины и т.д.).
- Для каждой формы, которую отправляет пользователь, можно выдавать уникальный одноразовый CSRF-токен, который будет проверяться на сервере после отправки формы. Это позволит избежать отправки вредоносных данных из поддельных форм.
- Вместо нормальных данных пользователь может отправлять код, который является SQL-инъекцией. 
